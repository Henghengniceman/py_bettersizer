#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Apr 28 13:54:30 2021

Read .xls output from bettersizer

@author: tobias
"""
import pandas as pd

    
def read_metadata(path, header_row=2, n_rows=6):
    xls_metadata = pd.read_excel(path, header=header_row).iloc[:n_rows]
    
    # drop empty columns
    for col in xls_metadata.columns:
        if all(xls_metadata.loc[:, col].isna()):
            xls_metadata = xls_metadata.drop(col, axis=1)
    
    metadata = dict()
    for row in xls_metadata.iterrows():
        for cell in row[1]:
            key, value = cell.split(':', maxsplit=1)
            metadata[key.strip()] = value.strip()
    return metadata


def read_analysis_data(path, first_row=8, last_row=10):
    xls_analysis_data = pd.read_excel(path).iloc[first_row: last_row]
    
    # drop empty columns
    for col in xls_analysis_data.columns:
        if all(xls_analysis_data.loc[:, col].isna()):
            xls_analysis_data = xls_analysis_data.drop(col, axis=1)
    
    analysis_data = dict()
    for row in xls_analysis_data.iterrows():
        for cell in row[1]:
            key, value = cell.split(':', maxsplit=1)
            analysis_data[key.strip()] = value.strip()
    return analysis_data


def read_sd_data(path, data_categories=['Diam um', 'Diff%', 'Cum%']):
    """
    Read the size distribution data from an xls sheet generated by the Bettersizer software.

    Parameters
    ----------
    path : str
        Path to the .xls file.

    Returns
    -------
    pd.DataFrame
        Contains the size distribution data from the xls sheet.

    """
    def get_data_header_row_idx(df):
        """Get the row index of data header"""
        for idx, row in df.iterrows():
            if any(row.astype('str').str.contains('(Diam um)')):
                return idx

    def get_data_category_columns(header_row, data_category):
        """Get a list of excel column names belonging to a data category"""
        return list(header_row[header_row.astype(str).str.contains(data_category)].index)
    
    def concat_columns(df, xls_header_row_idx, xls_category_column_names):
        """Concatenate columns which belong to the same category"""
        s = pd.Series(dtype=float)
        
        for col_name in xls_category_column_names:
            ss = df.loc[xls_header_row_idx + 1:, col_name]  # subseries
            
            # delete cells after first entry which contains NaN
            fist_nan_idx = ss[ss.isna()].index.min()
            indices_after_first_nan_idx = ss.loc[fist_nan_idx:].index
            ss = ss.drop(indices_after_first_nan_idx)
            
            s = s.append(ss, ignore_index=True)
        return s
    
    xls_df = pd.read_excel(path)
    xls_header_row_idx = get_data_header_row_idx(xls_df)
    
    data = pd.DataFrame()
    for data_category in data_categories:
        xls_category_column_names = get_data_category_columns(xls_df.loc[xls_header_row_idx], data_category)
        data[data_category] = concat_columns(xls_df, xls_header_row_idx, xls_category_column_names)
    
    return data


def read_system_status(path):
    """Reads the cell with system status information and splits the alphabetical keys"""
    import re
    
    def find_string_coordinates_in_df(df, string):
        for col in df.columns:
            if any(df[col].astype(str).str.contains(string)):
                idx = df[col][df[col].astype(str).str.contains(string)].index
                return (idx, col)
    
    xls_df = pd.read_excel(path)
    cell_coords = find_string_coordinates_in_df(xls_df, 'System Status')
    xls_sys_status = xls_df.loc[cell_coords[0], cell_coords[1]].item()

    sys_status = dict()
    separated_entries = re.split(r'\s+', xls_sys_status)
    for entry in separated_entries:
        if ':' in entry:
            key, value = entry.split(':')
            sys_status[key] = value
        else:
            continue

    return sys_status
